{% load static %}

<div id="spinner-container" class="spinner-container">
    <div class="spinner"></div>
</div>

{% block content %}
{% include 'components/scheduler-editor.html' %}
{% endblock %}

<script src="{% static 'js/recurring-control.js' %}"></script>
<script src="{% static 'js/appointment.js' %}"></script>
<script>
    let clientSearch;
    let locationSearch;
    document.addEventListener('DOMContentLoaded', function () {
        const resourceData = JSON.parse('{{ clinicians|safe }}');
        const clientData = JSON.parse('{{ clients|safe }}');
        const locationData = JSON.parse('{{ locations|safe }}');
        const teamMemberData = JSON.parse('{{ team_members|safe }}');

        let currentResourceId = null;
        // Initialize Scheduler
        const scheduler = new ej.schedule.Schedule({
            width: '100%',
            height: '100%',
            selectedDate: new Date(),
            cssClass: 'tailwind-scheduler',
            currentView: 'Day',
            views: [
                { option: 'Day' },
                { option: 'Week' },
                { option: 'Month' }
            ],
            group: {
                resources: ['Resources']
            },
            resources: [{
                field: 'ResourceId',
                title: 'Clinicians',
                name: 'Resources',
                dataSource: resourceData,
                textField: 'text',
                idField: 'id',
                colorField: 'color'
            }],
            timezone: 'America/New_York',
            eventSettings: {
                dataSource: [],
                fields: {
                    id: 'Id',
                    startTime: { name: 'StartTime' },
                    endTime: { name: 'EndTime' },
                    isAllDay: { name: 'IsAllDay' },
                    resourceId: { name: 'ResourceId' }
                },
                enableRecurrenceValidation: true
            },
            editorTemplate: '#EventEditorTemplate',
            popupOpen: function (args) {
                if (args.type === 'Editor') {
                    initializeEditorComponents(args);
                    // Store the resourceId from args
                    currentResourceId = args.data.ResourceId;
                }
                if (args.type === 'QuickInfo') {
                    args.cancel = true;
                }
            },
            actionBegin: function (args) {
                if (args.requestType === 'eventCreate' || args.requestType === 'eventChange' || args.requestType === 'eventRemove') {
                    const eventData = args.data[0] || args.data;
                    // Determine the active tab and set the eventType accordingly
                    const activeTab = document.querySelector('.editor-tab.active').getAttribute('data-tab');
                    let eventType;

                    switch (activeTab) {
                        case 'appointment':
                            eventType = 'APPOINTMENT';
                            break;
                        case 'event':
                            eventType = 'EVENT';
                            break;
                        case 'out_of_office':
                            eventType = 'OUT_OF_OFFICE';
                            break;
                        default:
                            eventType = 'APPOINTMENT';
                    }
                    document.getElementById('spinner-container').style.display = 'flex';
                    fetch(window.location.href, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCsrfToken()
                        },
                        body: JSON.stringify({
                            action: action,
                            eventType: eventType,
                            ...recurrenceData,
                            resourceId: resourceId
                        })
                    })
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === 'success') {
                                // Refresh the calendar data after successful creation
                                fetch(window.location.href, {
                                    headers: {
                                        'X-Requested-With': 'XMLHttpRequest'
                                    }
                                })
                                    .then(response => response.json())
                                    .then(updatedData => {
                                        scheduler.eventSettings.dataSource = updatedData;
                                        scheduler.dataBind();
                                    })
                                    .catch(error => {
                                        console.error('Error loading updated events:', error);
                                    });
                            }
                            document.getElementById('spinner-container').style.display = 'none';
                        });
                }
            },
            timeScale: {
                enable: true,
                interval: 60,
                slotCount: window.innerWidth < 768 ? 1 : 2
            },
            rowAutoHeight: false,
            allowResizing: window.innerWidth >= 768,
            allowDragAndDrop: window.innerWidth >= 768
        });

        scheduler.appendTo('#scheduler');

        // Utility function to get start and end dates based on the view
        function getStartAndEndDates(selectedDate, selectedView) {
            let startDate, endDate;

            switch (selectedView) {
                case 'Day':
                    startDate = new Date(selectedDate);
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(selectedDate);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'Week':
                    startDate = new Date(selectedDate);
                    startDate.setDate(selectedDate.getDate() - selectedDate.getDay());
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(startDate);
                    endDate.setDate(startDate.getDate() + 6);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'Month':
                    startDate = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), 1);
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(selectedDate.getFullYear(), selectedDate.getMonth() + 1, 0);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                default:
                    return null;
            }

            return { startDate, endDate };
        }
        // Load initial events
        const currentDate = scheduler.selectedDate;
        const selectedView = scheduler.currentView;

        const { startDate, endDate } = getStartAndEndDates(currentDate, selectedView);

        // Fetch events for the selected date range
        fetch(`${window.location.href}?start_date=${startDate.toISOString()}&end_date=${endDate.toISOString()}`, {
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
            .then(response => response.json())
            .then(data => {
                scheduler.eventSettings.dataSource = data;
                scheduler.dataBind();
            })
            .catch(error => {
                console.error('Error loading events:', error);
            });

        // Update navigationClick method
        scheduler.navigationClick = function (args) {
            const selectedView = scheduler.currentView;
            const selectedDate = scheduler.selectedDate;

            const { startDate, endDate } = getStartAndEndDates(selectedDate, selectedView);

            // Fetch events for the selected date range
            fetch(`${window.location.href}?start_date=${startDate.toISOString()}&end_date=${endDate.toISOString()}`, {
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            })
                .then(response => response.json())
                .then(data => {
                    scheduler.eventSettings.dataSource = data;
                    scheduler.dataBind();
                })
                .catch(error => {
                    console.error('Error loading events:', error);
                });
        };

        // Update navigating method
        scheduler.navigating = function (args) {
            if (args.action === 'date' || args.action === 'view') {
                const selectedDate = args.currentDate || scheduler.selectedDate;
                let selectedView;

                // Determine the view based on the action
                if (args.action === 'view') {
                    selectedView = args.currentView;
                } else {
                    selectedView = scheduler.currentView;
                }

                const { startDate, endDate } = getStartAndEndDates(selectedDate, selectedView);

                fetch(`${window.location.href}?start_date=${startDate.toISOString()}&end_date=${endDate.toISOString()}`, {
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                })
                    .then(response => response.json())
                    .then(data => {
                        scheduler.eventSettings.dataSource = data;
                        scheduler.dataBind();
                    })
                    .catch(error => {
                        console.error('Error loading events:', error);
                    });
            }
        };

        // Handle window resize
        window.addEventListener('resize', function () {
            scheduler.timeScale.slotCount = window.innerWidth < 768 ? 1 : 2;
            scheduler.allowResizing = window.innerWidth >= 768;
            scheduler.allowDragAndDrop = window.innerWidth >= 768;
            scheduler.dataBind();
        });

      
        $(document).on('click', '#appointment-done-button', function () {
            // Clear any existing error messages
            clearErrorMessages();

            // Get selected client and location
            const selectedClient = clientSearch.getSelectedItem();
            const selectedLocation = locationSearch.getSelectedItem();

            // Call the createAppointment function
            createAppointment(selectedClient, selectedLocation, scheduler);
        });
        
        $(document).on('click', '#cancel-button', function () {
            scheduler.closeEditor();
        });

        // Initialize editor components
        function initializeEditorComponents(args) {
            const container = args.element;

            // Initialize all components

            // Tab Navigation
            const tabs = document.querySelectorAll('.tab-link');
            tabs.forEach(tab => {
                tab.addEventListener('click', (e) => {
                    e.preventDefault();
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                });
            });

            // Appointment Type Selection
            const typeButtons = document.querySelectorAll('.type-btn');
            typeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    typeButtons.forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                });
            });


            initializeClientSearch(clientData);
            initializeDateTimePicker(args.data);
            initializeLocationDropdown(locationData);
            initializeRecurringControl(args.data.StartTime);
            // initializeInput(container);
            // initializeTeamMembersSearch(container, teamMemberData);
            // initializeOutOfOfficeFields(container);


            // // Recurrence Editor initialization
            // let recurElement = container.querySelector('#RecurrenceEditor');
            // if (recurElement && !recurElement.classList.contains('e-recurrenceeditor')) {
            //     let recurrObject = new ej.schedule.RecurrenceEditor({
            //         // You can add specific configuration here if needed
            //     });
            //     recurrObject.appendTo(recurElement);
            //     scheduler.eventWindow.recurrenceEditor = recurrObject;
            // }

            // initializeTabs(args, container);
        }

    });
    // Tab initialization function
    function initializeTabs(args, container) {
        const tabs = container.querySelectorAll('.editor-tab');
        const contents = container.querySelectorAll('.tab-content');
        const commonFields = container.querySelector('.common-fields');
        const clientField = container.querySelector('.client-field');
        const teamMemberField = container.querySelector('.team-member-field');
        const locationField = container.querySelector('.location-field');
        const recurrenceField = container.querySelector('.recurrence-field');
        const eventNameField = container.querySelector('.event-name-field');

        // Set initial active tab based on args.data.Type
        const eventType = (args.data.Type || 'APPOINTMENT').toLowerCase();
        const initialTab = container.querySelector(`.editor-tab[data-tab="${eventType}"]`);
        const initialContent = container.querySelector(`#${eventType}-tab`);

        if (initialTab && initialContent) {
            // Remove active class from all tabs and contents
            tabs.forEach(t => t.classList.remove('active'));
            contents.forEach(c => c.classList.remove('active'));

            // Set initial active tab and content
            initialTab.classList.add('active');
            initialContent.classList.add('active');

            // Show common fields
            commonFields.style.display = 'block';

            // Toggle fields for initial tab
            toggleFieldsByType(eventType, args, container);
        }

        // Add click event listeners for tab switching
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs and contents
                tabs.forEach(t => t.classList.remove('active'));
                contents.forEach(c => c.classList.remove('active'));

                // Add active class to clicked tab and its content
                tab.classList.add('active');
                const contentId = `${tab.getAttribute('data-tab')}-tab`;
                const contentElement = container.querySelector(`#${contentId}`);
                contentElement.classList.add('active');

                // Show common fields
                commonFields.style.display = 'block';

                // Call the function to toggle fields based on the active tab type
                toggleFieldsByType(tab.getAttribute('data-tab'), args, container);
            });
        });
    }
    function toggleFieldsByType(type, args, container) {
        const clientField = document.querySelector('.client-field');
        const locationField = document.querySelector('.location-field');
        const recurrenceField = document.querySelector('.recurrence-field');
        const eventNameField = document.querySelector('.event-name-field');
        const teamMemberField = document.querySelector('.team-member-field');
        const cancelAppointmentField = document.querySelector('.cancel-appointment-field');

        // Reset visibility
        clientField.style.display = 'none';
        locationField.style.display = 'none';
        recurrenceField.style.display = 'none';
        eventNameField.style.display = 'none';
        teamMemberField.style.display = 'none';
        cancelAppointmentField.style.display = 'none';

        switch (type) {
            case 'appointment':
                clientField.style.display = 'block';
                locationField.style.display = 'block';
                recurrenceField.style.display = 'block';
                if (args.data.Type === 'APPOINTMENT') {
                    bindAppointmentData(args, container);
                }
                break;
            case 'event':
                locationField.style.display = 'block';
                recurrenceField.style.display = 'block';
                eventNameField.style.display = 'block';
                teamMemberField.style.display = 'block';
                if (args.data.Type === 'EVENT') {
                    bindEventData(args, container);
                }
                break;
            case 'out_of_office':
                teamMemberField.style.display = 'block';
                cancelAppointmentField.style.display = 'block';
                if (args.data.Type === 'OUT_OF_OFFICE') {
                    bindOutOfOfficeData(args, container);
                }
                break;
            default:
                break;
        }
    }

    function bindAppointmentData(args, container) {
        // Set selected client if available
        if (args.data.Client) {
            const clientDropdown = container.querySelector('#Client');
            const clientDropDownList = clientDropdown.ej2_instances[0];
            clientDropDownList.value = args.data.Client;
            clientDropDownList.dataBind();
        }

        // Set selected location if available
        if (args.data.Location) {
            const locationDropdown = container.querySelector('#Location');
            const locationDropDownList = locationDropdown.ej2_instances[0];
            locationDropDownList.value = args.data.Location;
            locationDropDownList.dataBind();
        }

        // Check if the event is recurring and apply the recurrence rule
        if (args.data.IsRecurring) {
            const recurrenceEditor = container.querySelector('#RecurrenceEditor');
            if (recurrenceEditor) {
                const recurrenceEditorObj = recurrenceEditor.ej2_instances[0];
                if (recurrenceEditorObj) {
                    recurrenceEditorObj.setRecurrenceRule(args.data.RecurrenceRuleString);
                    recurrenceEditorObj.dataBind();
                    recurrenceEditorObj.recurrenceId = args.data.RecurrenceID;
                }
            }
        }

        // Bind IsAllDay checkbox
        const isAllDayCheckbox = container.querySelector('#IsAllDay');
        if (isAllDayCheckbox) {
            const isAllDayInstance = isAllDayCheckbox.ej2_instances[0];
            isAllDayInstance.checked = args.data.IsAllDay;
            isAllDayInstance.dataBind();

            updateDateTimePickers(container, args.data.IsAllDay);
        }
    }

    function bindEventData(args, container) {
        // Bind title for events
        const subjectInput = container.querySelector('input[name="Subject"]');
        if (subjectInput && !subjectInput.ej2_instances) {
            new ej.inputs.TextBox({
                placeholder: 'Event Name (Optional)',
                floatLabelType: 'Auto',
                value: args.data.Subject
            }, subjectInput);
        }

        if (args.data.TeamMember) {
            const teamMemberDropdown = container.querySelector('#TeamMember');
            const teamMemberDropDownList = teamMemberDropdown.ej2_instances[0];
            teamMemberDropDownList.value = args.data.TeamMember;
            teamMemberDropDownList.dataBind();
        }

        // Set selected location if available
        if (args.data.Location) {
            const locationDropdown = container.querySelector('#Location');
            const locationDropDownList = locationDropdown.ej2_instances[0];
            locationDropDownList.value = args.data.Location;
            locationDropDownList.dataBind();
        }

        // Check if the event is recurring and apply the recurrence rule
        if (args.data.IsRecurring) {
            const recurrenceEditor = container.querySelector('#RecurrenceEditor');
            if (recurrenceEditor) {
                const recurrenceEditorObj = recurrenceEditor.ej2_instances[0];
                if (recurrenceEditorObj) {
                    recurrenceEditorObj.setRecurrenceRule(args.data.RecurrenceRuleString);
                    recurrenceEditorObj.dataBind();
                    recurrenceEditorObj.recurrenceId = args.data.RecurrenceID;
                }
            }
        }

        // Bind IsAllDay checkbox
        const isAllDayCheckbox = container.querySelector('#IsAllDay');
        if (isAllDayCheckbox) {
            const isAllDayInstance = isAllDayCheckbox.ej2_instances[0];
            isAllDayInstance.checked = args.data.IsAllDay;
            isAllDayInstance.dataBind();

            updateDateTimePickers(container, args.data.IsAllDay);
        }
    }

    function bindOutOfOfficeData(args, container) {

        if (args.data.TeamMember) {
            const teamMemberDropdown = container.querySelector('#TeamMember');
            const teamMemberDropDownList = teamMemberDropdown.ej2_instances[0];
            teamMemberDropDownList.value = args.data.TeamMember;
            teamMemberDropDownList.dataBind();
        }
        const cancelAppointmentCheckbox = container.querySelector('#IsCancelAppointment');
        if (cancelAppointmentCheckbox) {
            const cancelAppointmentInstance = cancelAppointmentCheckbox.ej2_instances[0];
            cancelAppointmentInstance.checked = args.data.IsCancelAppointment;
            cancelAppointmentInstance.dataBind();
        }

        const notifyClientCheckbox = container.querySelector('#IsNotifyClient');
        if (notifyClientCheckbox) {
            const notifyClientInstance = notifyClientCheckbox.ej2_instances[0];
            notifyClientInstance.checked = args.data.IsNotifyClient;
            notifyClientInstance.dataBind();
        }

        // Bind IsAllDay checkbox
        const isAllDayCheckbox = container.querySelector('#IsAllDay');
        if (isAllDayCheckbox) {
            const isAllDayInstance = isAllDayCheckbox.ej2_instances[0];
            isAllDayInstance.checked = args.data.IsAllDay;
            isAllDayInstance.dataBind();

            updateDateTimePickers(container, args.data.IsAllDay);
        }
    }
   
    // Date/time pickers initialization function
    function initializeDateTimePicker(dateData) {
        // Cache all DOM elements
        const elements = {
            // Regular view elements
            dateInput: document.querySelector('.datetime-section .date-input'),
            startDate: document.getElementById('startDate'),
            startTimeInput: document.getElementById('startTime'),
            endTimeInput: document.getElementById('endTime'),
            durationInput: document.getElementById('duration'),
            regularTimeView: document.getElementById('regularTimeView'),

            // All-day view elements
            allDayCheckbox: document.getElementById('allDay'),
            allDayView: document.getElementById('allDayView'),
            allDayStartDate: document.getElementById('allDayStartDate'),
            allDayEndDate: document.getElementById('allDayEndDate'),
            numberOfDays: document.getElementById('numberOfDays')
        };

        // Helper Functions
        const helpers = {
            formatTimeToHHMM(date) {
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${hours}:${minutes}`;
            },

            formatDateToYYYYMMDD(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            },

            calculateDuration() {
                if (elements.startTimeInput?.value && elements.endTimeInput?.value) {
                    const start = new Date(`2000-01-01T${elements.startTimeInput.value}`);
                    const end = new Date(`2000-01-01T${elements.endTimeInput.value}`);
                    const duration = (end - start) / (1000 * 60);
                    if (elements.durationInput) {
                        elements.durationInput.value = duration >= 0 ? duration : 0;
                    }
                }
            },

            calculateNumberOfDays() {
                if (elements.allDayStartDate?.value && elements.allDayEndDate?.value) {
                    const start = new Date(elements.allDayStartDate.value);
                    const end = new Date(elements.allDayEndDate.value);
                    const diffTime = Math.abs(end - start);
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
                    if (elements.numberOfDays) {
                        elements.numberOfDays.value = diffDays;
                    }
                }
            },

            toggleViews(isAllDay) {
                if (elements.regularTimeView) {
                    elements.regularTimeView.style.display = isAllDay ? 'none' : 'flex';
                    elements.startDate.style.display = isAllDay ? 'none' : 'block';
                }
                if (elements.allDayView) {
                    elements.allDayView.style.display = isAllDay ? 'block' : 'none';
                }
            },

            syncViewData(isAllDay) {
                if (isAllDay) {
                    // Regular to All-day
                    if (elements.allDayStartDate && elements.dateInput) {
                        elements.allDayStartDate.value = elements.dateInput.value;
                    }
                    if (elements.allDayEndDate && elements.dateInput) {
                        elements.allDayEndDate.value = elements.dateInput.value;
                    }
                    helpers.calculateNumberOfDays();
                } else {
                    // All-day to Regular
                    if (elements.dateInput && elements.allDayStartDate) {
                        elements.dateInput.value = elements.allDayStartDate.value;
                    }
                    helpers.calculateDuration();
                }
            }
        };

        // Initialize event listeners
        function initializeEventListeners() {
            // All-day toggle
            elements.allDayCheckbox?.addEventListener('change', (e) => {
                const isAllDay = e.target.checked;
                helpers.toggleViews(isAllDay);
                helpers.syncViewData(isAllDay);
            });

            // Regular view time changes
            elements.startTimeInput?.addEventListener('change', helpers.calculateDuration);
            elements.endTimeInput?.addEventListener('change', helpers.calculateDuration);

            // All-day view date changes
            elements.allDayStartDate?.addEventListener('change', helpers.calculateNumberOfDays);
            elements.allDayEndDate?.addEventListener('change', helpers.calculateNumberOfDays);
        }

        // Initialize with data
        function initializeWithData() {
            try {
                const startDateTime = new Date(dateData.StartTime);
                const endDateTime = new Date(dateData.EndTime);

                if (isNaN(startDateTime.getTime()) || isNaN(endDateTime.getTime())) {
                    console.error('Invalid date values:', dateData.StartTime, dateData.EndTime);
                    return;
                }

                // Set regular view values
                if (elements.dateInput) {
                    elements.dateInput.value = helpers.formatDateToYYYYMMDD(startDateTime);
                }
                if (elements.startTimeInput) {
                    elements.startTimeInput.value = helpers.formatTimeToHHMM(startDateTime);
                }
                if (elements.endTimeInput) {
                    elements.endTimeInput.value = helpers.formatTimeToHHMM(endDateTime);
                }

                // Set all-day view values
                if (elements.allDayStartDate) {
                    elements.allDayStartDate.value = helpers.formatDateToYYYYMMDD(startDateTime);
                }
                if (elements.allDayEndDate) {
                    elements.allDayEndDate.value = helpers.formatDateToYYYYMMDD(endDateTime);
                }

                // Calculate initial values
                helpers.calculateDuration();
                helpers.calculateNumberOfDays();

                // Set initial view based on IsAllDay
                const isAllDay = dateData.IsAllDay || false;
                if (elements.allDayCheckbox) {
                    elements.allDayCheckbox.checked = isAllDay;
                }
                helpers.toggleViews(isAllDay);

            } catch (error) {
                console.error('Error initializing date/time pickers:', error);
            }
        }

        // Initialize everything
        initializeEventListeners();
        if (dateData) {
            initializeWithData();
        }
    }
    // Location dropdown initialization function
    function initializeLocationDropdown(locations) {
        locationSearch = new DynamicSearch({
            containerId: 'locationSearchContainer',
            items: locations,
            onSelect: function (selectedLocation) {
                console.log('Selected location:', selectedLocation);
                // Handle the selection here
            }
        });
        if (locations.length > 0) {
            const firstLocation = locations[0];
            locationSearch.selectItem(firstLocation);
            console.log('Automatically selected location:', firstLocation);
        }
    }


    // Function to update date/time pickers when AllDay is toggled
    function updateDateTimePickers(container, isAllDay) {
        const startTimeInputs = container.querySelectorAll('input[name="StartTime"]');
        const endTimeInputs = container.querySelectorAll('input[name="EndTime"]');

        startTimeInputs.forEach(input => {
            if (input.ej2_instances) {
                const currentDate = input.ej2_instances[0].value;
                input.ej2_instances[0].destroy();

                if (isAllDay) {
                    new ej.calendars.DatePicker({
                        value: currentDate,
                        format: 'yyyy-MM-dd'
                    }, input);
                } else {
                    new ej.calendars.DateTimePicker({
                        value: currentDate,
                        format: 'MM/dd/yyyy hh:mm a',
                        change: function (args) {
                            // Update end time date when start time changes
                            const endInput = container.querySelector('input[name="EndTime"]');
                            if (endInput && endInput.ej2_instances && endInput.ej2_instances[0]) {
                                const endTime = endInput.ej2_instances[0].value;
                                const newEndDate = new Date(args.value);
                                newEndDate.setHours(endTime.getHours(), endTime.getMinutes());
                                endInput.ej2_instances[0].value = newEndDate;
                            }
                        }
                    }, input);
                }
            }
        });

        endTimeInputs.forEach(input => {
            if (input.ej2_instances) {
                const currentDate = input.ej2_instances[0].value;
                input.ej2_instances[0].destroy();

                if (isAllDay) {
                    new ej.calendars.DatePicker({
                        value: currentDate,
                        format: 'yyyy-MM-dd',
                        enabled: false
                    }, input);
                } else {
                    new ej.calendars.DateTimePicker({
                        value: currentDate,
                        format: 'hh:mm a',
                        step: 15,
                        change: function (args) {
                            // Get date from start time and apply to end time
                            const startInput = container.querySelector('input[name="StartTime"]');
                            if (startInput && startInput.ej2_instances && startInput.ej2_instances[0]) {
                                const startDate = startInput.ej2_instances[0].value;
                                const newDate = new Date(args.value);
                                newDate.setFullYear(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                                args.value = newDate;
                            }
                        }
                    }, input);
                }
            }
        });
    }

    function initializeInput(container) {
        const subjectInput = container.querySelector('input[name="Subject"]');

        if (subjectInput && !subjectInput.ej2_instances) {
            new ej.inputs.TextBox({
                placeholder: 'Event Name (Optional)',
                floatLabelType: 'Auto'
            }, subjectInput);
        }
    }

    function initializeOutOfOfficeFields(container) {
        const cancelAppointmentCheckbox = container.querySelector('#IsCancelAppointment');
        if (cancelAppointmentCheckbox && !cancelAppointmentCheckbox.ej2_instances) {
            new ej.buttons.CheckBox({
                checked: false,
            }, cancelAppointmentCheckbox);
        }
        const notifyClientCheckbox = container.querySelector('#IsNotifyClient');
        if (notifyClientCheckbox && !notifyClientCheckbox.ej2_instances) {
            new ej.buttons.CheckBox({
                checked: false,
            }, notifyClientCheckbox);
        }
    }

    function initializeTeamMembersSearch(container, teamMembers) {
        const teamMemberSearch = container.querySelector('#TeamMember');

        const dropDownList = new ej.dropdowns.DropDownList({
            dataSource: teamMembers,
            fields: { text: 'name', value: 'id' },
            placeholder: 'Search Team Member',
            allowFiltering: true,
            popupHeight: '200px',
            filtering: (e) => {
                const query = new ej.data.Query().where('name', 'contains', e.text, true);
                e.updateData(teamMembers, query);
            }
        });

        dropDownList.appendTo(teamMemberSearch);
    }

</script>
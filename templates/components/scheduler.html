{% load static %}

<div id="spinner-container" class="spinner-container">
    <div class="spinner"></div>
</div>

{% block content %}
{% include 'components/scheduler-editor.html' %}
{% endblock %}


<script>
    document.addEventListener('DOMContentLoaded', function () {
        const resourceData = JSON.parse('{{ clinicians|safe }}');
        const clientData = JSON.parse('{{ clients|safe }}');
        const locationData = JSON.parse('{{ locations|safe }}');

        let currentResourceId = null;
        // Initialize Scheduler
        const scheduler = new ej.schedule.Schedule({
            width: '100%',
            height: '100%',
            selectedDate: new Date(),
            cssClass: 'tailwind-scheduler',
            currentView: 'Day',
            views: [
                { option: 'Day' },
                { option: 'Week' },
                { option: 'Month' }
            ],
            group: {
                resources: ['Resources']
            },
            resources: [{
                field: 'ResourceId',
                title: 'Clinicians',
                name: 'Resources',
                dataSource: resourceData,
                textField: 'text',
                idField: 'id',
                colorField: 'color'
            }],
            timezone: 'America/New_York',
            eventSettings: {
                dataSource: [],
                fields: {
                    id: 'Id',
                    startTime: { name: 'StartTime' },
                    endTime: { name: 'EndTime' },
                    isAllDay: { name: 'IsAllDay' },
                    resourceId: { name: 'ResourceId' },
                    recurrenceID: { name: 'RecurrenceID' },
                    recurrenceRule: { name: 'RecurrenceRule' },
                    recurrenceException: { name: 'RecurrenceException' }
                },
                enableRecurrenceValidation: true
            },
            editorTemplate: '#EventEditorTemplate',
            popupOpen: function (args) {
                if (args.type === 'Editor') {
                    initializeEditorComponents(args);

                    // Store the resourceId from args
                    currentResourceId = args.data.ResourceId;


                }
                if (args.type === 'QuickInfo') {
                    args.cancel = true;
                }
            },
            actionBegin: function (args) {
                if (args.requestType === 'eventCreate' || args.requestType === 'eventChange' || args.requestType === 'eventRemove') {
                    const eventData = args.data[0] || args.data;
                    if (args.requestType === 'eventCreate' || args.requestType === 'eventChange') {
                        // Get the editor element
                        const editorElement = document.querySelector('.e-schedule-dialog');

                        // Get the client and location dropdowns
                        const clientDropdown = editorElement.querySelector('#Client').ej2_instances[0];
                        const locationDropdown = editorElement.querySelector('#location').ej2_instances[0];

                        // Validate fields
                        if (!clientDropdown.value || !locationDropdown.value) {
                            args.cancel = true; // Prevent the event from being created/modified

                            // Show error message
                            const errorMessage = [];
                            if (!clientDropdown.value) errorMessage.push('Client');
                            if (!locationDropdown.value) errorMessage.push('Location');

                            alert(`Please select ${errorMessage.join(' and ')} before saving.`);
                            return;
                        }

                        // Ensure end date matches start date
                        const startTime = new Date(eventData.StartTime);
                        let endTime = new Date(eventData.EndTime);

                        // Set the end date to match start date while preserving end time
                        endTime = new Date(
                            startTime.getFullYear(),
                            startTime.getMonth(),
                            startTime.getDate(),
                            endTime.getHours(),
                            endTime.getMinutes()
                        );

                        // Update the end time in eventData
                        eventData.EndTime = endTime.toISOString();

                        // Validate time
                        if (startTime >= endTime) {
                            args.cancel = true;
                            alert('Start time must be less than end time.');
                            return;
                        }
                    }
                    const action = args.requestType.replace('event', '').toLowerCase();
                    const resourceId = currentResourceId;

                    const recurrenceData = {
                        ...eventData,
                        RecurrenceRule: eventData.RecurrenceRule || null,
                        RecurrenceException: eventData.RecurrenceException || null
                    };
                    // For recurring event modifications
                    if (args.requestType === 'eventChange') {
                        // Check if this is a series or occurrence edit
                        if (args.data.RecurrenceRule) {
                            // Series edit
                            recurrenceData.editType = 'series';
                        } else {
                            // Single occurrence edit
                            recurrenceData.editType = 'occurrence';
                            recurrenceData.originalEventId = args.data.RecurrenceID;
                        }
                    }

                    // Determine the active tab and set the eventType accordingly
                    const activeTab = document.querySelector('.editor-tab.active').getAttribute('data-tab');
                    let eventType;

                    switch (activeTab) {
                        case 'appointment':
                            eventType = 'APPOINTMENT';
                            break;
                        case 'event':
                            eventType = 'EVENT';
                            break;
                        case 'outofoffice':
                            eventType = 'OUT_OF_OFFICE';
                            break;
                        default:
                            eventType = 'APPOINTMENT';
                    }
                    document.getElementById('spinner-container').style.display = 'flex';
                    fetch(window.location.href, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCsrfToken()
                        },
                        body: JSON.stringify({
                            action: action,
                            eventType: eventType,
                            ...recurrenceData,
                            resourceId: resourceId
                        })
                    })
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === 'success') {
                                // Refresh the calendar data after successful creation
                                fetch(window.location.href, {
                                    headers: {
                                        'X-Requested-With': 'XMLHttpRequest'
                                    }
                                })
                                    .then(response => response.json())
                                    .then(updatedData => {
                                        scheduler.eventSettings.dataSource = updatedData;
                                        scheduler.dataBind();
                                    })
                                    .catch(error => {
                                        console.error('Error loading updated events:', error);
                                    });
                            }
                            document.getElementById('spinner-container').style.display = 'none';
                        });
                }
            },
            timeScale: {
                enable: true,
                interval: 60,
                slotCount: window.innerWidth < 768 ? 1 : 2
            },
            rowAutoHeight: false,
            allowResizing: window.innerWidth >= 768,
            allowDragAndDrop: window.innerWidth >= 768
        });

        scheduler.appendTo('#scheduler');

        // Utility function to get start and end dates based on the view
        function getStartAndEndDates(selectedDate, selectedView) {
            let startDate, endDate;

            switch (selectedView) {
                case 'Day':
                    startDate = new Date(selectedDate);
                    endDate = new Date(selectedDate);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'Week':
                    startDate = new Date(selectedDate);
                    startDate.setDate(selectedDate.getDate() - selectedDate.getDay());
                    endDate = new Date(startDate);
                    endDate.setDate(startDate.getDate() + 6);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'Month':
                    startDate = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), 1);
                    endDate = new Date(selectedDate.getFullYear(), selectedDate.getMonth() + 1, 0);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                default:
                    return null; // Handle other views if necessary
            }

            return { startDate, endDate };
        }

        // Load initial events
        const currentDate = scheduler.selectedDate;
        const selectedView = scheduler.currentView;

        const { startDate, endDate } = getStartAndEndDates(currentDate, selectedView);

        // Fetch events for the selected date range
        fetch(`${window.location.href}?start_date=${startDate.toISOString()}&end_date=${endDate.toISOString()}`, {
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
            .then(response => response.json())
            .then(data => {
                scheduler.eventSettings.dataSource = data;
                scheduler.dataBind();
            })
            .catch(error => {
                console.error('Error loading events:', error);
            });

        // Update navigationClick method
        scheduler.navigationClick = function (args) {
            const selectedView = scheduler.currentView;
            const selectedDate = scheduler.selectedDate;

            const { startDate, endDate } = getStartAndEndDates(selectedDate, selectedView);

            // Fetch events for the selected date range
            fetch(`${window.location.href}?start_date=${startDate.toISOString()}&end_date=${endDate.toISOString()}`, {
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            })
                .then(response => response.json())
                .then(data => {
                    scheduler.eventSettings.dataSource = data;
                    scheduler.dataBind();
                })
                .catch(error => {
                    console.error('Error loading events:', error);
                });
        };

        // Update navigating method
        scheduler.navigating = function (args) {
            if (args.action === 'date' || args.action === 'view') {
                const selectedDate = args.currentDate || scheduler.selectedDate;
                let selectedView;

                // Determine the view based on the action
                if (args.action === 'view') {
                    selectedView = args.currentView;
                } else {
                    selectedView = scheduler.currentView;
                }

                const { startDate, endDate } = getStartAndEndDates(selectedDate, selectedView);

                fetch(`${window.location.href}?start_date=${startDate.toISOString()}&end_date=${endDate.toISOString()}`, {
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                })
                    .then(response => response.json())
                    .then(data => {
                        scheduler.eventSettings.dataSource = data;
                        scheduler.dataBind();
                    })
                    .catch(error => {
                        console.error('Error loading events:', error);
                    });
            }
        };

        // Handle window resize
        window.addEventListener('resize', function () {
            scheduler.timeScale.slotCount = window.innerWidth < 768 ? 1 : 2;
            scheduler.allowResizing = window.innerWidth >= 768;
            scheduler.allowDragAndDrop = window.innerWidth >= 768;
            scheduler.dataBind();
        });

        // Initialize editor components
        function initializeEditorComponents(args) {
            const container = args.element;

            // Initialize all components
            initializeTabs(container);
            initializeClientSearch(container, clientData);
            initializeDateTimePickers(container);
            initializeLocationDropdown(container, locationData);

            // Bind existing data
            bindExistingData(args, container);
        }

        function bindExistingData(args, container) {
            // Recurrence Editor initialization
            let recurElement = container.querySelector('#RecurrenceEditor');
            if (recurElement && !recurElement.classList.contains('e-recurrenceeditor')) {
                let recurrObject = new ej.schedule.RecurrenceEditor({
                    // You can add specific configuration here if needed
                });
                recurrObject.appendTo(recurElement);
                scheduler.eventWindow.recurrenceEditor = recurrObject;
            }

            // Set selected client and location if available
            if (args.data.Client) {
                const clientDropdown = container.querySelector('#Client');
                const clientDropDownList = clientDropdown.ej2_instances[0];
                clientDropDownList.value = args.data.Client;
                clientDropDownList.dataBind();
            }

            if (args.data.Location) {
                const locationDropdown = container.querySelector('#location');
                const locationDropDownList = locationDropdown.ej2_instances[0];
                locationDropDownList.value = args.data.Location;
                locationDropDownList.dataBind();
            }

            // Check if the event is recurring and apply the recurrence rule
            if (args.data.IsRecurring) {
                const recurrenceEditor = container.querySelector('#RecurrenceEditor');
                if (recurrenceEditor) {
                    const recurrenceEditorObj = recurrenceEditor.ej2_instances[0];
                    if (recurrenceEditorObj) {
                        recurrenceEditorObj.setRecurrenceRule(args.data.RecurrenceRuleString);
                        recurrenceEditorObj.dataBind();
                        recurrenceEditorObj.recurrenceId = args.data.RecurrenceID;
                    }
                }
            }

            // Bind IsAllDay checkbox
            const isAllDayCheckbox = container.querySelector('#IsAllDay');
            if (isAllDayCheckbox) {
                const isAllDayInstance = isAllDayCheckbox.ej2_instances[0];
                isAllDayInstance.checked = args.data.IsAllDay;
                isAllDayInstance.dataBind();

                if (args.data.IsAllDay) {
                    updateDateTimePickers(container, true);
                } else {
                    updateDateTimePickers(container, false);
                }
            }
        }
    });
    // Tab initialization function
    function initializeTabs(container) {
        const tabs = container.querySelectorAll('.editor-tab');
        const contents = container.querySelectorAll('.tab-content');

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs and contents
                tabs.forEach(t => t.classList.remove('active'));
                contents.forEach(c => c.classList.remove('active'));

                // Add active class to clicked tab and its content
                tab.classList.add('active');
                const contentId = `${tab.getAttribute('data-tab')}-tab`;
                container.querySelector(`#${contentId}`).classList.add('active');
            });
        });

    }

    // Updated client search initialization
    function initializeClientSearch(container, clients) {
        const clientSearch = container.querySelector('#Client');

        const dropDownList = new ej.dropdowns.DropDownList({
            dataSource: clients,
            fields: { text: 'name', value: 'id' },
            placeholder: 'Search Client',
            allowFiltering: true,
            popupHeight: '200px',
            filtering: (e) => {
                const query = new ej.data.Query().where('name', 'contains', e.text, true);
                e.updateData(clients, query);
            }
        });

        dropDownList.appendTo(clientSearch);
    }
    // Date/time pickers initialization function
    function initializeDateTimePickers(container) {
        const startTimeInputs = container.querySelectorAll('input[name="StartTime"]');
        const endTimeInputs = container.querySelectorAll('input[name="EndTime"]');
        const isAllDayInputs = container.querySelectorAll('input[name="IsAllDay"]');

        // Initialize IsAllDay checkbox
        isAllDayInputs.forEach(input => {
            if (!input.classList.contains('e-checkbox')) {
                new ej.buttons.CheckBox({
                    checked: false,
                    change: (e) => {
                        updateDateTimePickers(container, e.checked);
                    }
                }, input);
            }
        });

        // Initialize date/time pickers
        function initializePickers(isAllDay = false) {
            startTimeInputs.forEach(input => {
                if (input.ej2_instances) {
                    input.ej2_instances[0].destroy();
                }

                new ej.calendars.DateTimePicker({
                    value: new Date(input.value) || new Date(),
                    format: 'MM/dd/yyyy HH:mm',
                    change: function (args) {
                        // Update end time with same date when start time changes
                        const endInput = container.querySelector('input[name="EndTime"]');
                        if (endInput && endInput.ej2_instances && endInput.ej2_instances[0]) {
                            const endTime = endInput.ej2_instances[0].value;
                            const newEndDate = new Date(args.value);
                            newEndDate.setHours(endTime.getHours(), endTime.getMinutes());
                            endInput.ej2_instances[0].value = newEndDate;
                        }
                    }
                }, input);
            });

            endTimeInputs.forEach(input => {
                if (input.ej2_instances) {
                    input.ej2_instances[0].destroy();
                }

                new ej.calendars.DateTimePicker({
                    value: new Date(input.value) || new Date(),
                    format: 'HH:mm',
                    enabled: !isAllDay,
                    depth: 'Hour',
                    start: 'Hour',
                    stepHour: 1,
                    stepMinute: 15,
                    dateDisabled: true, // Disable date selection
                    change: function (args) {
                        const startInput = container.querySelector('input[name="StartTime"]');
                        if (startInput && startInput.ej2_instances && startInput.ej2_instances[0]) {
                            const startDate = startInput.ej2_instances[0].value;
                            const newDate = new Date(args.value);
                            newDate.setFullYear(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                            args.value = newDate;
                        }
                    }
                }, input);
            });
        }

        // Initial setup
        const isAllDay = container.querySelector('input[name="IsAllDay"]').ej2_instances[0].checked;
        initializePickers(isAllDay);
    }

    // Location dropdown initialization function
    function initializeLocationDropdown(container, locations) {
        const locationDropdown = container.querySelector('input[name="location"]');

        const dropDownList = new ej.dropdowns.DropDownList({
            dataSource: locations,
            fields: { text: 'name', value: 'id' },
            placeholder: 'Select Location',
            allowFiltering: true,
            filtering: (e) => {
                const query = new ej.data.Query().where('name', 'contains', e.text, true);
                e.updateData(locations, query);
            }
        });

        dropDownList.appendTo(locationDropdown);
    }
    // Utility function to get CSRF token
    function getCsrfToken() {
        const csrfCookie = document.cookie
            .split(';')
            .find(cookie => cookie.trim().startsWith('csrftoken='));
        return csrfCookie ? csrfCookie.split('=')[1] : '';
    }

    // Function to update date/time pickers when AllDay is toggled
    function updateDateTimePickers(container, isAllDay) {
        const startTimeInputs = container.querySelectorAll('input[name="StartTime"]');
        const endTimeInputs = container.querySelectorAll('input[name="EndTime"]');

        startTimeInputs.forEach(input => {
            if (input.ej2_instances) {
                const currentDate = input.ej2_instances[0].value;
                input.ej2_instances[0].destroy();

                if (isAllDay) {
                    new ej.calendars.DatePicker({
                        value: currentDate,
                        format: 'yyyy-MM-dd'
                    }, input);
                } else {
                    new ej.calendars.DateTimePicker({
                        value: currentDate,
                        format: 'yyyy-MM-dd HH:mm',
                        change: function (args) {
                            // Update end time date when start time changes
                            const endInput = container.querySelector('input[name="EndTime"]');
                            if (endInput && endInput.ej2_instances && endInput.ej2_instances[0]) {
                                const endTime = endInput.ej2_instances[0].value;
                                const newEndDate = new Date(args.value);
                                newEndDate.setHours(endTime.getHours(), endTime.getMinutes());
                                endInput.ej2_instances[0].value = newEndDate;
                            }
                        }
                    }, input);
                }
            }
        });

        endTimeInputs.forEach(input => {
            if (input.ej2_instances) {
                const currentDate = input.ej2_instances[0].value;
                input.ej2_instances[0].destroy();

                if (isAllDay) {
                    new ej.calendars.DatePicker({
                        value: currentDate,
                        format: 'yyyy-MM-dd',
                        enabled: false
                    }, input);
                } else {
                    new ej.calendars.DateTimePicker({
                        value: currentDate,
                        format: 'HH:mm',
                        step: 15,
                        change: function (args) {
                            // Get date from start time and apply to end time
                            const startInput = container.querySelector('input[name="StartTime"]');
                            if (startInput && startInput.ej2_instances && startInput.ej2_instances[0]) {
                                const startDate = startInput.ej2_instances[0].value;
                                const newDate = new Date(args.value);
                                newDate.setFullYear(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                                args.value = newDate;
                            }
                        }
                    }, input);
                }
            }
        });
    }
</script>